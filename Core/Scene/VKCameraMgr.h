#ifndef VK_CAMERA_MGR_H
#define VK_CAMERA_MGR_H
/* The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default. We need 
 * to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition
*/
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
/* The GLM_FORCE_RADIANS definition is necessary to make sure that glm functions use radians as arguments, to avoid any 
 * possible confusion
*/
#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
/* The glm/gtc/matrix_transform.hpp header exposes functions that can be used to generate model transformations like 
 * glm::rotate, view transformations like glm::lookAt and projection transformations like glm::perspective
*/
#include <glm/gtc/matrix_transform.hpp>
#include "../Device/VKDeviceMgr.h"

using namespace Collections;

namespace Renderer {
    class VKCameraMgr: protected virtual VKDeviceMgr {
        private:
            struct CameraInfo {
                struct Meta {
                    glm::mat4 viewMatrix;
                    glm::mat4 projectionMatrix;
                } meta;
            };
            std::map <uint32_t, CameraInfo> m_cameraInfoPool;

            static Log::Record* m_VKCameraMgrLog;
            const uint32_t m_instanceId = g_collectionsId++;

            void deleteCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end()) {
                    m_cameraInfoPool.erase (cameraInfoId);
                    return;
                }

                LOG_ERROR (m_VKCameraMgrLog) << "Failed to delete camera info "
                                             << "[" << cameraInfoId << "]"          
                                             << std::endl;
                throw std::runtime_error ("Failed to delete camera info");
            }
            
        public:
            VKCameraMgr (void) {
                m_VKCameraMgrLog = LOG_INIT (m_instanceId, g_pathSettings.logSaveDir);
                LOG_ADD_CONFIG (m_instanceId, Log::INFO,  Log::TO_FILE_IMMEDIATE);
                LOG_ADD_CONFIG (m_instanceId, Log::ERROR, Log::TO_FILE_IMMEDIATE | Log::TO_CONSOLE); 
            }

            ~VKCameraMgr (void) { 
                LOG_CLOSE (m_instanceId);
            }

        protected:
            void readyCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end()) {
                    LOG_ERROR (m_VKCameraMgrLog) << "Camera info id already exists "
                                                 << "[" << cameraInfoId << "]"
                                                 << std::endl;
                    throw std::runtime_error ("Camera info id already exists");
                }

                CameraInfo info{};
                m_cameraInfoPool[cameraInfoId] = info;
            }

            void createCameraMatrix (uint32_t cameraInfoId,
                                     uint32_t resourceId,
                                     const glm::vec3& cameraPos, 
                                     const glm::vec3& center,
                                     const glm::vec3& upVector,
                                     float fovDeg, 
                                     float nearPlane, 
                                     float farPlane) {

                createViewMatrix (cameraInfoId,
                                  cameraPos, center, upVector);

                createProjectionMatrix (cameraInfoId,
                                        resourceId,
                                        fovDeg, nearPlane, farPlane);
            }

            void createViewMatrix (uint32_t cameraInfoId,
                                   const glm::vec3& cameraPos, 
                                   const glm::vec3& center,
                                   const glm::vec3& upVector) {
                
                auto cameraInfo = getCameraInfo (cameraInfoId);
                /* The glm::lookAt function takes the eye (camera) position, where you want to look at, in world space, 
                 * and up axis as parameters
                 * 
                 * The up vector is basically a vector defining your world's "upwards" direction. In almost all normal 
                 * cases, this will be the vector (0, 1, 0) i.e. towards positive Y
                 * 
                 * Note that, we need to take care of how the vertices are being drawn, whether in counter-clockwise 
                 * order or clockwise order, since it might cause backface culling to kick in and prevent any geometry 
                 * from being drawn
                */
                cameraInfo->meta.viewMatrix = glm::lookAt (cameraPos, center, upVector);
            }

            void createProjectionMatrix (uint32_t cameraInfoId,
                                         uint32_t resourceId,
                                         float fovDeg, 
                                         float nearPlane, 
                                         float farPlane) {

                auto cameraInfo = getCameraInfo (cameraInfoId);
                auto deviceInfo = getDeviceInfo();
                /* It is important to use the current swap chain extent to calculate the aspect ratio to take into account
                 * the new width and height of the window after a resize
                */
                float aspectRatio = deviceInfo->unique[resourceId].swapChain.extent.width / 
                                    static_cast <float> (deviceInfo->unique[resourceId].swapChain.extent.height);
                cameraInfo->meta.projectionMatrix = glm::perspective (glm::radians (fovDeg), 
                                                                      aspectRatio, 
                                                                      nearPlane, 
                                                                      farPlane);
                /* GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted. 
                 * The easiest way to compensate for that is to flip the sign on the scaling factor of the Y axis in the 
                 * projection matrix. If you don't do this, then the image will be rendered upside down
                 * 
                 * OpenGL                                       Vulkan
                 *              +Y                              -Y
                 *              |                               |
                 *              |                               |
                 *              |                               |
                 *              |-----------| +X                |-----------| +X
                 *             /                               /
                 *            /                               /
                 *           /                               /
                 *          +Z                              -Z
                */
                cameraInfo->meta.projectionMatrix[1][1] *= -1;
            }

            CameraInfo* getCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end())
                    return &m_cameraInfoPool[cameraInfoId];
                
                LOG_ERROR (m_VKCameraMgrLog) << "Failed to find camera info "
                                             << "[" << cameraInfoId << "]"
                                             << std::endl;
                throw std::runtime_error ("Failed to find camera info");                
            }

            void dumpCameraInfoPool (void) {
                LOG_INFO (m_VKCameraMgrLog) << "Dumping camera info pool"
                                            << std::endl;

                for (auto const& [key, val]: m_cameraInfoPool) {
                    LOG_INFO (m_VKCameraMgrLog) << "Camera info id " 
                                                << "[" << key << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "View matrix" 
                                                << std::endl; 
                    uint32_t rowIdx = 0;
                    while (rowIdx < 4) {
                        LOG_INFO (m_VKCameraMgrLog) << "["
                                                    << val.meta.viewMatrix[rowIdx][0] << " "
                                                    << val.meta.viewMatrix[rowIdx][1] << " "
                                                    << val.meta.viewMatrix[rowIdx][2] << " "
                                                    << val.meta.viewMatrix[rowIdx][3]
                                                    << "]"
                                                    << std::endl;
                        rowIdx++;
                    }                                                

                    LOG_INFO (m_VKCameraMgrLog) << "Projection matrix"
                                                << std::endl;
                    rowIdx = 0;
                    while (rowIdx < 4) {
                        LOG_INFO (m_VKCameraMgrLog) << "["
                                                    << val.meta.projectionMatrix[rowIdx][0] << " "
                                                    << val.meta.projectionMatrix[rowIdx][1] << " "
                                                    << val.meta.projectionMatrix[rowIdx][2] << " "
                                                    << val.meta.projectionMatrix[rowIdx][3]
                                                    << "]"
                                                    << std::endl;
                        rowIdx++;
                    }                                                                                                   
                }
            }

            void cleanUp (uint32_t cameraInfoId) {
                deleteCameraInfo (cameraInfoId);
            }
    };

    Log::Record* VKCameraMgr::m_VKCameraMgrLog;
}   // namespace Renderer
#endif  // VK_CAMERA_MGR_H