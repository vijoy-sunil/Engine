#ifndef VK_CAMERA_MGR_H
#define VK_CAMERA_MGR_H
/* The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default. We need
 * to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition
*/
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
/* The GLM_FORCE_RADIANS definition is necessary to make sure that glm functions use radians as arguments, to avoid any
 * possible confusion
*/
#define GLM_FORCE_RADIANS
/* The glm/gtc/matrix_transform.hpp header exposes functions that can be used to generate model transformations like
 * glm::rotate, view transformations like glm::lookAt and projection transformations like glm::perspective
*/
#include <glm/gtc/matrix_transform.hpp>
#include "../Device/VKDeviceMgr.h"

namespace Core {
    class VKCameraMgr: protected virtual VKDeviceMgr {
        private:
            struct CameraInfo {
                struct Meta {
                    glm::vec3 position;
                    glm::vec3 direction;
                    glm::vec3 upVector;

                    float fovDeg;
                    float nearPlane;
                    float farPlane;

                    bool updateViewMatrix;
                    bool updateProjectionMatrix;
                } meta;

                struct Transform {
                    glm::mat4 viewMatrix;
                    glm::mat4 projectionMatrix;
                } transform;
            };
            std::unordered_map <uint32_t, CameraInfo> m_cameraInfoPool;

            Log::Record* m_VKCameraMgrLog;
            const uint32_t m_instanceId = g_collectionSettings.instanceId++;

            void deleteCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end()) {
                    m_cameraInfoPool.erase (cameraInfoId);
                    return;
                }

                LOG_ERROR (m_VKCameraMgrLog) << "Failed to delete camera info "
                                             << "[" << cameraInfoId << "]"
                                             << std::endl;
                throw std::runtime_error ("Failed to delete camera info");
            }

        public:
            VKCameraMgr (void) {
                m_VKCameraMgrLog = LOG_INIT (m_instanceId, g_collectionSettings.logSaveDirPath);
                LOG_ADD_CONFIG (m_instanceId, Log::INFO,  Log::TO_FILE_IMMEDIATE);
                LOG_ADD_CONFIG (m_instanceId, Log::ERROR, Log::TO_FILE_IMMEDIATE | Log::TO_CONSOLE);
            }

            ~VKCameraMgr (void) {
                LOG_CLOSE (m_instanceId);
            }

        protected:
            void readyCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end()) {
                    LOG_ERROR (m_VKCameraMgrLog) << "Camera info id already exists "
                                                 << "[" << cameraInfoId << "]"
                                                 << std::endl;
                    throw std::runtime_error ("Camera info id already exists");
                }

                CameraInfo info{};
                m_cameraInfoPool[cameraInfoId] = info;
            }

            void createCameraMatrix (uint32_t deviceInfoId, uint32_t cameraInfoId) {
                createViewMatrix       (cameraInfoId);
                createProjectionMatrix (deviceInfoId, cameraInfoId);
            }

            void createViewMatrix (uint32_t cameraInfoId) {
                auto cameraInfo = getCameraInfo (cameraInfoId);
                /* The glm::lookAt function takes the eye (camera) position, where you want to look at, in world space,
                 * and up axis as parameters
                 *
                 * The up vector is basically a vector defining your world's "upwards" direction
                 *
                 * Note that, we need to take care of how the vertices are being drawn, whether in counter-clockwise
                 * order or clockwise order, since it might cause backface culling to kick in and prevent any geometry
                 * from being drawn
                 *
                 * The direction that the camera looks at is the current position + the direction vector. This ensures
                 * that however we move, the camera keeps looking at the target direction
                */
                cameraInfo->transform.viewMatrix = glm::lookAt (cameraInfo->meta.position,
                                                                cameraInfo->meta.position + cameraInfo->meta.direction,
                                                                cameraInfo->meta.upVector);
            }

            void createProjectionMatrix (uint32_t deviceInfoId, uint32_t cameraInfoId) {
                auto deviceInfo = getDeviceInfo (deviceInfoId);
                auto cameraInfo = getCameraInfo (cameraInfoId);
                /* It is important to use the current swap chain extent to calculate the aspect ratio to take into account
                 * the new width and height of the window after a resize
                */
                float aspectRatio = deviceInfo->params.swapChainExtent.width/
                                    static_cast <float> (deviceInfo->params.swapChainExtent.height);
                cameraInfo->transform.projectionMatrix = glm::perspective (glm::radians (cameraInfo->meta.fovDeg),
                                                                           aspectRatio,
                                                                           cameraInfo->meta.nearPlane,
                                                                           cameraInfo->meta.farPlane);
                /* GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted.
                 * The easiest way to compensate for that is to flip the sign on the scaling factor of the Y axis in the
                 * projection matrix. If you don't do this, then the image will be rendered upside down
                 *
                 * OpenGL                                       Vulkan
                 *              +Y                              -Y
                 *              |                               |
                 *              |                               |
                 *              |                               |
                 *              |-----------| +X                |-----------| +X
                 *             /                               /
                 *            /                               /
                 *           /                               /
                 *          +Z                              -Z
                */
                cameraInfo->transform.projectionMatrix[1][1] *= -1;
            }

            CameraInfo* getCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end())
                    return &m_cameraInfoPool[cameraInfoId];

                LOG_ERROR (m_VKCameraMgrLog) << "Failed to find camera info "
                                             << "[" << cameraInfoId << "]"
                                             << std::endl;
                throw std::runtime_error ("Failed to find camera info");
            }

            void dumpCameraInfoPool (void) {
                LOG_INFO (m_VKCameraMgrLog) << "Dumping camera info pool"
                                            << std::endl;

                for (auto const& [key, val]: m_cameraInfoPool) {
                    LOG_INFO (m_VKCameraMgrLog) << "Camera info id "
                                                << "[" << key << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Position "
                                                << "[" << val.meta.position.x << ", "
                                                       << val.meta.position.y << ", "
                                                       << val.meta.position.z
                                                << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Direction "
                                                << "[" << val.meta.direction.x << ", "
                                                       << val.meta.direction.y << ", "
                                                       << val.meta.direction.z
                                                << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Up vector "
                                                << "[" << val.meta.upVector.x << ", "
                                                       << val.meta.upVector.y << ", "
                                                       << val.meta.upVector.z
                                                << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "FOV degrees "
                                                << "[" << val.meta.fovDeg << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Near plane "
                                                << "[" << val.meta.nearPlane << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Far plane "
                                                << "[" << val.meta.farPlane << "]"
                                                << std::endl;

                    std::string boolString = val.meta.updateViewMatrix       == true ? "TRUE": "FALSE";
                    LOG_INFO (m_VKCameraMgrLog) << "Update view matrix "
                                                << "[" << boolString << "]"
                                                << std::endl;

                    boolString             = val.meta.updateProjectionMatrix == true ? "TRUE": "FALSE";
                    LOG_INFO (m_VKCameraMgrLog) << "Update projection matrix "
                                                << "[" << boolString << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "View matrix"
                                                << std::endl;
                    uint32_t rowIdx = 0;
                    while (rowIdx < 4) {
                        LOG_INFO (m_VKCameraMgrLog) << "["
                                                    << val.transform.viewMatrix[rowIdx][0] << " "
                                                    << val.transform.viewMatrix[rowIdx][1] << " "
                                                    << val.transform.viewMatrix[rowIdx][2] << " "
                                                    << val.transform.viewMatrix[rowIdx][3]
                                                    << "]"
                                                    << std::endl;
                        rowIdx++;
                    }

                    LOG_INFO (m_VKCameraMgrLog) << "Projection matrix"
                                                << std::endl;
                    rowIdx = 0;
                    while (rowIdx < 4) {
                        LOG_INFO (m_VKCameraMgrLog) << "["
                                                    << val.transform.projectionMatrix[rowIdx][0] << " "
                                                    << val.transform.projectionMatrix[rowIdx][1] << " "
                                                    << val.transform.projectionMatrix[rowIdx][2] << " "
                                                    << val.transform.projectionMatrix[rowIdx][3]
                                                    << "]"
                                                    << std::endl;
                        rowIdx++;
                    }
                }
            }

            void cleanUp (uint32_t cameraInfoId) {
                deleteCameraInfo (cameraInfoId);
            }
    };
}   // namespace Core
#endif  // VK_CAMERA_MGR_H