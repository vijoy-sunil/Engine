#ifndef VK_CAMERA_MGR_H
#define VK_CAMERA_MGR_H
/* The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default. We need 
 * to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition
*/
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
/* The GLM_FORCE_RADIANS definition is necessary to make sure that glm functions use radians as arguments, to avoid any 
 * possible confusion
*/
#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
/* The glm/gtc/matrix_transform.hpp header exposes functions that can be used to generate model transformations like 
 * glm::rotate, view transformations like glm::lookAt and projection transformations like glm::perspective
*/
#include <glm/gtc/matrix_transform.hpp>
#include "../Device/VKDeviceMgr.h"

using namespace Collections;

namespace Renderer {
    class VKCameraMgr: protected virtual VKDeviceMgr {
        private:
            struct CameraInfo {
                struct Meta {
                    glm::vec3 position; 
                    glm::vec3 center;
                    glm::vec3 upVector;

                    float fovDeg; 
                    float nearPlane; 
                    float farPlane;

                    bool updateViewMatrix;
                    bool updateProjectionMatrix;
                } meta;

                struct Transform {
                    glm::mat4 view;
                    glm::mat4 projection;
                } transform;
            };
            std::map <uint32_t, CameraInfo> m_cameraInfoPool;

            static Log::Record* m_VKCameraMgrLog;
            const uint32_t m_instanceId = g_collectionsId++;

            void deleteCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end()) {
                    m_cameraInfoPool.erase (cameraInfoId);
                    return;
                }

                LOG_ERROR (m_VKCameraMgrLog) << "Failed to delete camera info "
                                             << "[" << cameraInfoId << "]"          
                                             << std::endl;
                throw std::runtime_error ("Failed to delete camera info");
            }
            
        public:
            VKCameraMgr (void) {
                m_VKCameraMgrLog = LOG_INIT (m_instanceId, g_pathSettings.logSaveDir);
                LOG_ADD_CONFIG (m_instanceId, Log::INFO,  Log::TO_FILE_IMMEDIATE);
                LOG_ADD_CONFIG (m_instanceId, Log::ERROR, Log::TO_FILE_IMMEDIATE | Log::TO_CONSOLE); 
            }

            ~VKCameraMgr (void) { 
                LOG_CLOSE (m_instanceId);
            }

        protected:
            void readyCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end()) {
                    LOG_ERROR (m_VKCameraMgrLog) << "Camera info id already exists "
                                                 << "[" << cameraInfoId << "]"
                                                 << std::endl;
                    throw std::runtime_error ("Camera info id already exists");
                }

                CameraInfo info{};
                m_cameraInfoPool[cameraInfoId] = info;
            }

            void createCameraMatrix (uint32_t cameraInfoId, uint32_t resourceId) {
                createViewMatrix       (cameraInfoId);
                createProjectionMatrix (cameraInfoId, resourceId);
            }

            void createViewMatrix (uint32_t cameraInfoId) {
                auto cameraInfo = getCameraInfo (cameraInfoId);
                /* The glm::lookAt function takes the eye (camera) position, where you want to look at, in world space, 
                 * and up axis as parameters
                 * 
                 * The up vector is basically a vector defining your world's "upwards" direction. In almost all normal 
                 * cases, this will be the vector (0, 1, 0) i.e. towards positive Y
                 * 
                 * Note that, we need to take care of how the vertices are being drawn, whether in counter-clockwise 
                 * order or clockwise order, since it might cause backface culling to kick in and prevent any geometry 
                 * from being drawn
                */
                cameraInfo->transform.view = glm::lookAt (cameraInfo->meta.position, 
                                                          cameraInfo->meta.center, 
                                                          cameraInfo->meta.upVector);
            }

            void createProjectionMatrix (uint32_t cameraInfoId, uint32_t resourceId) {
                auto cameraInfo = getCameraInfo (cameraInfoId);
                auto deviceInfo = getDeviceInfo();
                /* It is important to use the current swap chain extent to calculate the aspect ratio to take into account
                 * the new width and height of the window after a resize
                */
                float aspectRatio = deviceInfo->unique[resourceId].swapChain.extent.width/ 
                                    static_cast <float> (deviceInfo->unique[resourceId].swapChain.extent.height);
                cameraInfo->transform.projection = glm::perspective (glm::radians (cameraInfo->meta.fovDeg), 
                                                                     aspectRatio, 
                                                                     cameraInfo->meta.nearPlane, 
                                                                     cameraInfo->meta.farPlane);
                /* GLM was originally designed for OpenGL, where the Y coordinate of the clip coordinates is inverted. 
                 * The easiest way to compensate for that is to flip the sign on the scaling factor of the Y axis in the 
                 * projection matrix. If you don't do this, then the image will be rendered upside down
                 * 
                 * OpenGL                                       Vulkan
                 *              +Y                              -Y
                 *              |                               |
                 *              |                               |
                 *              |                               |
                 *              |-----------| +X                |-----------| +X
                 *             /                               /
                 *            /                               /
                 *           /                               /
                 *          +Z                              -Z
                */
                cameraInfo->transform.projection[1][1] *= -1;
            }

            CameraInfo* getCameraInfo (uint32_t cameraInfoId) {
                if (m_cameraInfoPool.find (cameraInfoId) != m_cameraInfoPool.end())
                    return &m_cameraInfoPool[cameraInfoId];
                
                LOG_ERROR (m_VKCameraMgrLog) << "Failed to find camera info "
                                             << "[" << cameraInfoId << "]"
                                             << std::endl;
                throw std::runtime_error ("Failed to find camera info");                
            }

            void dumpCameraInfoPool (void) {
                LOG_INFO (m_VKCameraMgrLog) << "Dumping camera info pool"
                                            << std::endl;

                for (auto const& [key, val]: m_cameraInfoPool) {
                    LOG_INFO (m_VKCameraMgrLog) << "Camera info id " 
                                                << "[" << key << "]"
                                                << std::endl;
 
                    LOG_INFO (m_VKCameraMgrLog) << "Position "
                                                << "[" << val.meta.position.x << ", "
                                                       << val.meta.position.y << ", "
                                                       << val.meta.position.z
                                                << "]"  
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Center "
                                                << "[" << val.meta.center.x << ", "
                                                       << val.meta.center.y << ", "
                                                       << val.meta.center.z
                                                << "]"  
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Up vector "
                                                << "[" << val.meta.upVector.x << ", "
                                                       << val.meta.upVector.y << ", "
                                                       << val.meta.upVector.z
                                                << "]"  
                                                << std::endl;  

                    LOG_INFO (m_VKCameraMgrLog) << "FOV degrees "
                                                << "[" << val.meta.fovDeg << "]" 
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Near plane "
                                                << "[" << val.meta.nearPlane << "]" 
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Far plane "
                                                << "[" << val.meta.farPlane << "]" 
                                                << std::endl; 

                    LOG_INFO (m_VKCameraMgrLog) << "Update view matrix " 
                                                << "[" << Utils::getBoolString (val.meta.updateViewMatrix) << "]"
                                                << std::endl;

                    LOG_INFO (m_VKCameraMgrLog) << "Update projection matrix " 
                                                << "[" << Utils::getBoolString (val.meta.updateProjectionMatrix) << "]"
                                                << std::endl;                                               

                    LOG_INFO (m_VKCameraMgrLog) << "View matrix" 
                                                << std::endl; 
                    uint32_t rowIdx = 0;
                    while (rowIdx < 4) {
                        LOG_INFO (m_VKCameraMgrLog) << "["
                                                    << val.transform.view[rowIdx][0] << " "
                                                    << val.transform.view[rowIdx][1] << " "
                                                    << val.transform.view[rowIdx][2] << " "
                                                    << val.transform.view[rowIdx][3]
                                                    << "]"
                                                    << std::endl;
                        rowIdx++;
                    }                                                

                    LOG_INFO (m_VKCameraMgrLog) << "Projection matrix"
                                                << std::endl;
                    rowIdx = 0;
                    while (rowIdx < 4) {
                        LOG_INFO (m_VKCameraMgrLog) << "["
                                                    << val.transform.projection[rowIdx][0] << " "
                                                    << val.transform.projection[rowIdx][1] << " "
                                                    << val.transform.projection[rowIdx][2] << " "
                                                    << val.transform.projection[rowIdx][3]
                                                    << "]"
                                                    << std::endl;
                        rowIdx++;
                    }                                                                                                   
                }
            }

            void cleanUp (uint32_t cameraInfoId) {
                deleteCameraInfo (cameraInfoId);
            }
    };

    Log::Record* VKCameraMgr::m_VKCameraMgrLog;
}   // namespace Renderer
#endif  // VK_CAMERA_MGR_H